<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RAG Demo — Phison aiDAPTIV</title>
  <style>
    :root {
      --pascari-yellow: #FFDD00;
      --pascari-blue: #1C3051;
      --pascari-white: #FFFFFF;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--pascari-yellow);
      color: var(--pascari-blue);
    }
    .app-layout {
      display: flex;
      min-height: 100vh;
      flex-wrap: wrap;
    }
    .app-main {
      flex: 1;
      min-width: 280px;
      padding: 1.5rem;
      max-width: 560px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    .app-sidebar {
      width: 480px;
      min-width: 400px;
      max-width: 100%;
      padding: 1.5rem;
      background: rgba(28, 48, 81, 0.06);
      border-left: 2px solid var(--pascari-blue);
      overflow-y: auto;
      max-height: 100vh;
    }
    .app-sidebar h2.sidebar-title {
      font-size: 0.85rem;
      margin: 0 0 1rem 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.9;
    }
    .container {
      max-width: 640px;
      margin: 0 auto;
      padding: 2rem;
    }
    h1 {
      color: var(--pascari-blue);
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      color: var(--pascari-blue);
      opacity: 0.85;
      font-size: 0.95rem;
      margin-bottom: 2rem;
    }
    .card {
      background: var(--pascari-white);
      color: var(--pascari-blue);
      border: 2px solid var(--pascari-blue);
      border-radius: 8px;
      padding: 1.25rem 1.5rem;
      margin-bottom: 1rem;
    }
    .card h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin: 0 0 0.5rem 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .card pre {
      margin: 0;
      font-size: 0.85rem;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .status.ok { background: var(--pascari-blue); color: var(--pascari-white); }
    .status.loading { background: var(--pascari-white); color: var(--pascari-blue); border: 1px solid var(--pascari-blue); }
    .status.error { background: #c00; color: var(--pascari-white); }
    /* Chat */
    .chat-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .chat-row input {
      flex: 1;
      padding: 0.6rem 0.75rem;
      font-size: 1rem;
      border: 2px solid var(--pascari-blue);
      border-radius: 6px;
      background: var(--pascari-white);
      color: var(--pascari-blue);
    }
    .chat-row input::placeholder { color: var(--pascari-blue); opacity: 0.6; }
    .btn {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .btn-primary {
      background: var(--pascari-blue);
      color: var(--pascari-white);
    }
    .btn-primary:hover { opacity: 0.9; }
    .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
    .reply-box {
      min-height: 4rem;
      padding: 1rem;
      background: var(--pascari-white);
      border: 2px solid var(--pascari-blue);
      border-radius: 8px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .reply-box.empty { color: #999; }
    .reply-box.error { background: #ffe0e0; border-color: #c00; }
    /* Conversation — main userland chat */
    .chat-card { flex: 1; display: flex; flex-direction: column; min-height: 0; }
    .conversation {
      flex: 1;
      min-height: 16rem;
      max-height: 50vh;
      overflow-y: auto;
      margin-top: 0.5rem;
      padding: 0.5rem 0;
      border-radius: 6px;
      background: rgba(28, 48, 81, 0.03);
    }
    .conversation:empty::before {
      content: 'Your prompts and replies will appear here.';
      display: block;
      color: var(--pascari-blue);
      opacity: 0.5;
      font-size: 0.9rem;
      padding: 1rem 0.75rem;
    }
    .msg { margin-bottom: 0.75rem; padding: 0.6rem 0.75rem; border-radius: 6px; font-size: 0.9rem; white-space: pre-wrap; word-break: break-word; }
    .msg.user { background: rgba(28, 48, 81, 0.08); border-left: 3px solid var(--pascari-blue); }
    .msg.assistant { background: var(--pascari-white); border: 1px solid var(--pascari-blue); }
    .msg.thinking { background: var(--pascari-white); border: 1px solid var(--pascari-blue); color: var(--pascari-blue); opacity: 0.9; }
    .msg .role { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.25rem; opacity: 0.9; }
    .thinking-dots { display: inline-flex; gap: 0.25rem; align-items: center; }
    .thinking-dots span { width: 6px; height: 6px; border-radius: 50%; background: var(--pascari-blue); animation: thinking-bounce 0.6s ease-in-out infinite; }
    .thinking-dots span:nth-child(2) { animation-delay: 0.1s; }
    .thinking-dots span:nth-child(3) { animation-delay: 0.2s; }
    @keyframes thinking-bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
    /* Search results */
    .search-status { font-size: 0.9rem; margin-bottom: 0.5rem; min-height: 1.25rem; }
    .search-results { margin-top: 0.5rem; }
    .chunk-item {
      background: var(--pascari-white);
      border: 1px solid var(--pascari-blue);
      border-radius: 6px;
      padding: 0.75rem 1rem;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
    .chunk-item .path { font-weight: 600; color: var(--pascari-blue); margin-bottom: 0.25rem; }
    .chunk-item .text { white-space: pre-wrap; word-break: break-word; max-height: 8em; overflow-y: auto; }
    .chunk-item .score { font-size: 0.75rem; opacity: 0.8; margin-top: 0.25rem; }
    /* Collapsible section */
    .collapsible-card .collapsible-header {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin: 0 0 0.5rem 0;
      padding: 0;
      border: none;
      background: none;
      font: inherit;
      color: inherit;
      text-align: left;
      width: 100%;
    }
    .collapsible-card .collapsible-header:hover { opacity: 0.9; }
    .collapsible-card .collapsible-header .chevron {
      display: inline-block;
      transition: transform 0.2s ease;
      font-size: 0.75rem;
    }
    .collapsible-card.collapsed .collapsible-header .chevron { transform: rotate(-90deg); }
    .collapsible-card .collapsible-body { margin-top: 0.25rem; }
    .collapsible-card.collapsed .collapsible-body { display: none; }
    /* Session metrics (Phase 6) */
    .session-metrics {
      font-size: 0.85rem;
      margin-bottom: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: rgba(28, 48, 81, 0.06);
      border-radius: 6px;
      color: var(--pascari-blue);
      border-left: 3px solid var(--pascari-blue);
    }
    .session-metrics.empty { display: none; }
    .session-metrics .label { font-weight: 600; margin-right: 0.5rem; }
    .session-metrics .value { opacity: 0.9; }
    /* Workload / corpus info in main UI */
    .workload-info {
      font-size: 0.85rem;
      padding: 0.5rem 0.75rem;
      margin-bottom: 1rem;
      background: rgba(28, 48, 81, 0.06);
      border-radius: 6px;
      color: var(--pascari-blue);
      border-left: 3px solid var(--pascari-blue);
    }
    .workload-info.empty { display: none; }
    .workload-info .wlabel { font-weight: 600; margin-right: 0.35rem; }
    .workload-info .wvalue { opacity: 0.95; }
    /* Per-turn metrics under each assistant reply */
    .msg-turn-metrics {
      font-size: 0.7rem;
      color: var(--pascari-blue);
      opacity: 0.8;
      margin-top: 0.5rem;
      padding-top: 0.35rem;
      border-top: 1px solid rgba(28, 48, 81, 0.15);
    }
    /* Degradation test */
    .degradation-results { display: none; margin-top: 1rem; }
    .degradation-results.visible { display: block; }
    .degradation-turn { margin-bottom: 0.75rem; border: 1px solid var(--pascari-blue); border-radius: 6px; overflow: hidden; }
    .degradation-turn-header { padding: 0.5rem 0.75rem; background: rgba(28, 48, 81, 0.08); cursor: pointer; font-weight: 600; font-size: 0.85rem; }
    .degradation-turn-body { padding: 0.75rem 1rem; font-size: 0.85rem; white-space: pre-wrap; word-break: break-word; max-height: 12rem; overflow-y: auto; }
    .degradation-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; margin-top: 0.5rem; }
    .degradation-table th, .degradation-table td { border: 1px solid var(--pascari-blue); padding: 0.35rem 0.5rem; text-align: left; }
    .degradation-table th { background: rgba(28, 48, 81, 0.1); }
    .degradation-charts { display: grid; gap: 1rem; margin-top: 1rem; }
    .degradation-chart { background: rgba(28, 48, 81, 0.04); border: 1px solid var(--pascari-blue); border-radius: 6px; padding: 0.75rem; }
    .degradation-chart h4 { margin: 0 0 0.5rem 0; font-size: 0.85rem; }
    .degradation-chart svg { width: 100%; height: 140px; display: block; }
    .degradation-chart .axis { stroke: var(--pascari-blue); stroke-width: 1; }
    .degradation-chart .tick { font-size: 10px; fill: var(--pascari-blue); }
    .degradation-chart .axis-label { font-size: 11px; font-weight: 600; fill: var(--pascari-blue); }
  </style>
</head>
<body>
  <div class="app-layout">
    <main class="app-main">
      <h1>RAG Demo</h1>
      <p class="subtitle">Phison aiDAPTIV — Coding assistant</p>
      <div id="workloadInfo" class="workload-info empty">Loading workload…</div>

    <div class="card collapsible-card collapsed" id="searchCard">
      <button type="button" class="collapsible-header" id="searchToggle" aria-expanded="false">
        <span class="chevron" aria-hidden="true">▼</span>
        <h2 style="margin:0">Search Transformers corpus</h2>
      </button>
      <div class="collapsible-body" id="searchBody">
        <p class="chat-row">
          <input type="text" id="searchQuery" placeholder="e.g. generation_config, attention mask…" />
          <button type="button" id="searchBtn" class="btn btn-primary">Search</button>
        </p>
        <div id="searchStatus" class="search-status"></div>
        <div id="searchResults" class="search-results"></div>
      </div>
    </div>

    <div class="card chat-card">
      <h2>Coding assistant (RAG)</h2>
      <p class="chat-row">
        <input type="text" id="prompt" placeholder="Ask about the Transformers codebase…" />
        <button type="button" id="send" class="btn btn-primary">Send</button>
      </p>
      <div id="conversation" class="conversation" aria-label="Chat: your prompts and assistant replies"></div>
      <div id="sessionMetrics" class="session-metrics"></div>
    </div>
    </main>

    <aside class="app-sidebar" aria-label="Metrics and telemetry">
      <h2 class="sidebar-title">Metrics &amp; telemetry</h2>

      <div class="card">
        <h2>Backend</h2>
        <p><span id="status" class="status loading">Checking…</span></p>
        <pre id="payload">—</pre>
      </div>

      <div class="card">
        <h2>Model</h2>
        <div id="modelInfo" class="session-metrics empty">Loading…</div>
      </div>

      <div class="card">
        <h2>Run Degradation Test</h2>
        <p>
          <button type="button" id="runDegradationBtn" class="btn btn-primary">Run Degradation Test</button>
        </p>
        <p><span id="degradationStatus" style="font-size:0.9rem;"></span></p>
        <p><button type="button" id="exportMetricsBtn" class="btn" style="font-size:0.85rem;padding:0.4rem 0.75rem;">Export metrics</button></p>
        <div id="degradationResults" class="degradation-results">
          <p id="degradationModelInfo" style="font-size:0.85rem;margin:0 0 0.5rem 0;color:var(--pascari-blue);"></p>
          <h3 style="font-size:1rem;margin:0 0 0.5rem 0;">Metrics</h3>
          <div id="degradationTableWrap" style="overflow-x:auto;"></div>
          <h3 style="font-size:1rem;margin:1rem 0 0.5rem 0;">Charts</h3>
          <div id="degradationCharts" class="degradation-charts"></div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const payloadEl = document.getElementById('payload');
    const searchQueryEl = document.getElementById('searchQuery');
    const searchBtnEl = document.getElementById('searchBtn');
    const searchStatusEl = document.getElementById('searchStatus');
    const searchResultsEl = document.getElementById('searchResults');
    const promptEl = document.getElementById('prompt');
    const sendEl = document.getElementById('send');
    const conversationEl = document.getElementById('conversation');
    const sessionMetricsEl = document.getElementById('sessionMetrics');
    const sidebarSessionEl = document.getElementById('sidebarSessionMetrics');
    const modelInfoEl = document.getElementById('modelInfo');
    const workloadInfoEl = document.getElementById('workloadInfo');

    let sessionId = null;
    const messages = [];
    let lastMetrics = null;
    let lastDegradationTurns = [];

    function renderSessionMetrics() {
      if (!lastMetrics) {
        sessionMetricsEl.innerHTML = '';
        sessionMetricsEl.classList.add('empty');
        if (sidebarSessionEl) {
          sidebarSessionEl.innerHTML = 'No active session. Use the chat to start.';
          sidebarSessionEl.classList.add('empty');
        }
        return;
      }
      sessionMetricsEl.classList.remove('empty');
      if (sidebarSessionEl) sidebarSessionEl.classList.remove('empty');
      const n = lastMetrics.message_count ?? 0;
      const ctx = lastMetrics.context_chars ?? 0;
      const rss = lastMetrics.process_rss_mb;
      let html = '<span class="label">Session:</span> <span class="value">' + n + ' message' + (n !== 1 ? 's' : '') + '</span>';
      html += ' &middot; <span class="label">Context:</span> <span class="value">' + ctx.toLocaleString() + ' chars</span>';
      if (rss != null) html += ' &middot; <span class="label">Memory:</span> <span class="value">' + rss + ' MB</span>';
      const lt = lastMetrics.last_turn;
      if (lt && lt.timing_ms) {
        const rm = lt.timing_ms.retrieve_ms;
        const im = lt.timing_ms.inference_ms;
        const ret = lt.rag && lt.rag.returned;
        const model = (lt.inference && lt.inference.model) || lt.model;
        html += '<br/><span class="label">Last turn:</span> <span class="value">retrieve ' + rm + 'ms, infer ' + im + 'ms, chunks ' + ret + (model ? (', model ' + escapeHtml(String(model))) : '') + '</span>';
      }
      sessionMetricsEl.innerHTML = html;
      if (sidebarSessionEl) sidebarSessionEl.innerHTML = html;
    }

    function formatTurnMetrics(t) {
      if (!t) return '';
      if (t.timing_ms) {
        const r = t.timing_ms.retrieve_ms;
        const i = t.timing_ms.inference_ms;
        const chunks = (t.rag && t.rag.returned != null) ? t.rag.returned : '';
        const chars = (t.sizes && t.sizes.prompt_chars != null) ? (t.sizes.prompt_chars >= 1000 ? (t.sizes.prompt_chars / 1000).toFixed(1) + 'k' : t.sizes.prompt_chars) : '';
        const parts = ['Retrieve ' + r + 'ms', 'Infer ' + i + 'ms'];
        if (chunks !== '') parts.push(chunks + ' chunks');
        if (chars) parts.push(chars + ' chars');
        return parts.join(' · ');
      }
      if (t.latency_ms != null || t.context_tokens != null) {
        const parts = [];
        if (t.context_tokens != null) parts.push('Context: ' + t.context_tokens + ' tok');
        if (t.latency_ms != null) parts.push('Latency: ' + (t.latency_ms >= 1000 ? (t.latency_ms / 1000).toFixed(1) + 's' : t.latency_ms + 'ms'));
        if (t.prompt_tokens != null) parts.push('Prompt: ' + t.prompt_tokens);
        if (t.completion_tokens != null) parts.push('Completion: ' + t.completion_tokens);
        if (t.retrieved_chunks != null) parts.push(t.retrieved_chunks + ' chunks');
        return parts.join(' · ');
      }
      return '';
    }

    function renderConversation() {
      conversationEl.innerHTML = '';
      messages.forEach((m) => {
        const div = document.createElement('div');
        div.className = 'msg ' + m.role + (m.thinking ? ' thinking' : '');
        if (m.thinking) {
          div.innerHTML = '<div class="role">assistant</div><div class="thinking-dots"><span></span><span></span><span></span></div> <span style="margin-left:0.35rem">Thinking…</span>';
        } else {
          let body = '<div class="role">' + escapeHtml(m.role) + '</div><div>' + escapeHtml(m.content) + '</div>';
          if (m.role === 'assistant' && m.turnMetrics) {
            const line = formatTurnMetrics(m.turnMetrics);
            if (line) body += '<div class="msg-turn-metrics">' + escapeHtml(line) + '</div>';
          }
          div.innerHTML = body;
        }
        conversationEl.appendChild(div);
      });
      conversationEl.scrollTop = conversationEl.scrollHeight;
    }

    async function check() {
      try {
        const res = await fetch(window.location.origin + '/api/hello');
        const data = await res.json();
        statusEl.textContent = 'OK';
        statusEl.className = 'status ok';
        payloadEl.textContent = JSON.stringify(data, null, 2);
      } catch (e) {
        statusEl.textContent = 'Error';
        statusEl.className = 'status error';
        payloadEl.textContent = e.message || String(e);
      }
      loadModelInfo();
      loadWorkloadInfo();
    }

    async function loadWorkloadInfo() {
      if (!workloadInfoEl) return;
      try {
        const res = await fetch(window.location.origin + '/api/corpus');
        const d = await res.json();
        if (d.num_chunks === 0 && d.num_files === 0) {
          workloadInfoEl.innerHTML = 'No index loaded. Run: <code>uv run python -m ingest</code>';
          workloadInfoEl.classList.remove('empty');
          return;
        }
        const name = escapeHtml(d.codebase_name || 'corpus');
        const files = (d.num_files ?? 0).toLocaleString();
        const chunks = (d.num_chunks ?? 0).toLocaleString();
        const lines = (d.total_lines ?? 0).toLocaleString();
        const chars = (d.total_chars ?? 0).toLocaleString();
        const idxMb = d.index_size_mb ?? 0;
        const metaMb = d.metadata_size_mb ?? 0;
        const totalMb = (idxMb + metaMb).toFixed(1);
        let html = '<span class="wlabel">Codebase:</span><span class="wvalue">' + name + '</span>';
        html += ' &middot; <span class="wlabel">Files:</span><span class="wvalue">' + files + '</span>';
        html += ' &middot; <span class="wlabel">Chunks:</span><span class="wvalue">' + chunks + '</span>';
        html += ' &middot; <span class="wlabel">Lines:</span><span class="wvalue">' + lines + '</span>';
        html += ' &middot; <span class="wlabel">Chars:</span><span class="wvalue">' + chars + '</span>';
        html += ' &middot; <span class="wlabel">Data size:</span><span class="wvalue">' + totalMb + ' MB</span>';
        workloadInfoEl.innerHTML = html;
        workloadInfoEl.classList.remove('empty');
      } catch (e) {
        workloadInfoEl.innerHTML = 'Workload info unavailable';
        workloadInfoEl.classList.remove('empty');
      }
    }

    async function loadModelInfo() {
      if (!modelInfoEl) return;
      try {
        const res = await fetch(window.location.origin + '/api/model-info');
        const d = await res.json();
        let html = '<span class="label">Model:</span> <span class="value">' + escapeHtml(d.model || '—') + '</span>';
        if (d.quant) html += ' &middot; <span class="label">Quant:</span> <span class="value">' + escapeHtml(String(d.quant)) + '</span>';
        if (d.parameter_size) html += ' &middot; <span class="label">Params:</span> <span class="value">' + escapeHtml(String(d.parameter_size)) + '</span>';
        html += ' &middot; <span class="label">Context:</span> <span class="value">' + (d.context_length != null ? d.context_length.toLocaleString() : '—') + '</span>';
        if (d.size_vram_mb != null) html += ' &middot; <span class="label">Mem:</span> <span class="value">' + d.size_vram_mb + ' MB</span>';
        modelInfoEl.innerHTML = html;
        modelInfoEl.classList.remove('empty');
      } catch (e) {
        modelInfoEl.innerHTML = 'Model info unavailable';
        modelInfoEl.classList.remove('empty');
      }
    }

    async function sendChat() {
      const prompt = promptEl.value.trim();
      if (!prompt) return;
      sendEl.disabled = true;
      messages.push({ role: 'user', content: prompt });
      messages.push({ role: 'assistant', content: '', thinking: true });
      promptEl.value = '';
      renderConversation();
      try {
        const res = await fetch(window.location.origin + '/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt, session_id: sessionId }),
        });
        let data = {};
        try { data = await res.json(); } catch (_) {}
        messages.pop(); // remove thinking placeholder
        if (!res.ok) {
          messages.pop(); // remove user message so we can show error as assistant reply
          messages.push({ role: 'assistant', content: data.detail || res.statusText || 'Request failed' });
          renderConversation();
          return;
        }
        if (data.session_id) sessionId = data.session_id;
        messages.push({
          role: 'assistant',
          content: data.reply || '(no reply)',
          turnMetrics: data.metrics && data.metrics.last_turn ? data.metrics.last_turn : null,
        });
        lastMetrics = data.metrics || { message_count: data.message_count ?? messages.length };
        if (lastMetrics.message_count == null) lastMetrics.message_count = messages.length;
        renderSessionMetrics();
        renderConversation();
      } catch (e) {
        messages.pop(); // remove thinking placeholder
        messages.pop(); // remove user message
        renderConversation();
        messages.push({ role: 'assistant', content: e.message || 'Request failed' });
        renderConversation();
      } finally {
        sendEl.disabled = false;
      }
    }

    async function searchCorpus() {
      const q = searchQueryEl.value.trim();
      if (!q) return;
      searchBtnEl.disabled = true;
      searchStatusEl.textContent = 'Searching…';
      searchResultsEl.innerHTML = '';
      try {
        const res = await fetch(window.location.origin + '/api/retrieve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: q, top_k: 10 }),
        });
        let data = {};
        try { data = await res.json(); } catch (_) {}
        if (!res.ok) {
          searchStatusEl.textContent = data.detail || res.statusText || 'Search failed';
          return;
        }
        const chunks = data.chunks || [];
        searchStatusEl.textContent = chunks.length ? `${chunks.length} chunk(s)` : 'No chunks found.';
        chunks.forEach((c) => {
          const div = document.createElement('div');
          div.className = 'chunk-item';
          const snippet = (c.text || '').slice(0, 500) + ((c.text || '').length > 500 ? '…' : '');
          div.innerHTML = `<div class="path">${escapeHtml(c.path)}</div><div class="text">${escapeHtml(snippet)}</div><div class="score">score: ${Number(c.score).toFixed(4)}</div>`;
          searchResultsEl.appendChild(div);
        });
      } catch (e) {
        searchStatusEl.textContent = e.message || 'Search failed';
      } finally {
        searchBtnEl.disabled = false;
      }
    }
    function escapeHtml(s) {
      const d = document.createElement('div');
      d.textContent = s;
      return d.innerHTML;
    }

    function drawLineChart(id, title, turns, getValue, width, height) {
      const values = turns.map((t, i) => getValue(t, i));
      const maxV = Math.max(1, ...values);
      const minV = Math.min(0, ...values);
      const range = maxV - minV || 1;
      const pad = { left: 36, right: 16, top: 12, bottom: 32 };
      const w = width - pad.left - pad.right;
      const h = height - pad.top - pad.bottom;
      const x = (i) => pad.left + (i / (values.length - 1 || 1)) * w;
      const y = (v) => pad.top + h - ((v - minV) / range) * h;
      const pts = values.map((v, i) => x(i) + ',' + y(v)).join(' ');
      const n = values.length;
      const yTicks = 5;
      const yStep = range / (yTicks - 1) || 1;
      let parts = [];
      parts.push('<svg viewBox="0 0 ' + width + ' ' + height + '" xmlns="http://www.w3.org/2000/svg"><title>' + escapeHtml(title) + '</title>');
      parts.push('<line class="axis" x1="' + pad.left + '" y1="' + (pad.top + h) + '" x2="' + (pad.left + w) + '" y2="' + (pad.top + h) + '"/>');
      parts.push('<line class="axis" x1="' + pad.left + '" y1="' + pad.top + '" x2="' + pad.left + '" y2="' + (pad.top + h) + '"/>');
      for (let i = 0; i < yTicks; i++) {
        const v = minV + i * yStep;
        const yy = pad.top + h - ((v - minV) / range) * h;
        parts.push('<line class="axis" x1="' + pad.left + '" y1="' + yy + '" x2="' + (pad.left - 4) + '" y2="' + yy + '"/>');
        parts.push('<text class="tick" x="' + (pad.left - 6) + '" y="' + (yy + 4) + '" text-anchor="end">' + Math.round(v) + '</text>');
      }
      const xStep = Math.max(1, Math.floor(n / 8));
      for (let i = 0; i < n; i += xStep) {
        const xx = x(i);
        parts.push('<line class="axis" x1="' + xx + '" y1="' + (pad.top + h) + '" x2="' + xx + '" y2="' + (pad.top + h + 4) + '"/>');
        parts.push('<text class="tick" x="' + xx + '" y="' + (pad.top + h + 18) + '" text-anchor="middle">' + (i + 1) + '</text>');
      }
      if (n > 0 && (n - 1) % xStep !== 0) {
        const xx = x(n - 1);
        parts.push('<line class="axis" x1="' + xx + '" y1="' + (pad.top + h) + '" x2="' + xx + '" y2="' + (pad.top + h + 4) + '"/>');
        parts.push('<text class="tick" x="' + xx + '" y="' + (pad.top + h + 18) + '" text-anchor="middle">' + n + '</text>');
      }
      parts.push('<text class="axis-label" x="' + (pad.left + w / 2) + '" y="' + (height - 6) + '" text-anchor="middle">Turn</text>');
      parts.push('<text class="axis-label" x="12" y="' + (pad.top + h / 2) + '" text-anchor="middle" transform="rotate(-90, 12, ' + (pad.top + h / 2) + ')">' + escapeHtml(title) + '</text>');
      parts.push('<polyline fill="none" stroke="var(--pascari-blue)" stroke-width="1.5" points="' + pts + '"/>');
      parts.push('</svg>');
      return parts.join('');
    }

    const NUM_DEGRADATION_TURNS = 15;

    function appendTurnToUI(t, tableWrap, turns) {
      const modelInfoEl = document.getElementById('degradationModelInfo');
      if (modelInfoEl) modelInfoEl.textContent = (t.model ? 'Model: ' + t.model : '');
      let table = '<table class="degradation-table"><thead><tr><th>Turn</th><th>Prompt tokens</th><th>Completion tokens</th><th>Context (tokens)</th><th>KVC (MB)</th><th>Retrieved chunks</th><th>Unique files</th><th>History turns</th><th>Latency (ms)</th></tr></thead><tbody>';
      turns.forEach((r) => {
        const m = r.metrics || {};
        const ctx = m.context_tokens ?? m.prompt_tokens ?? '';
        const kvc = m.kv_cache_mb != null ? m.kv_cache_mb : '—';
        table += '<tr><td>' + r.turn + '</td><td>' + (m.prompt_tokens ?? '') + '</td><td>' + (m.completion_tokens ?? '') + '</td><td>' + ctx + '</td><td>' + kvc + '</td><td>' + (m.retrieved_chunks ?? '') + '</td><td>' + (m.unique_files ?? '') + '</td><td>' + (m.history_turns ?? '') + '</td><td>' + (m.latency_ms ?? '') + '</td></tr>';
      });
      table += '</tbody></table>';
      tableWrap.innerHTML = table;
    }

    async function exportMetrics() {
      if (!lastDegradationTurns.length) {
        if (typeof document.getElementById('degradationStatus') !== 'undefined') {
          document.getElementById('degradationStatus').textContent = 'Run a degradation test first to export metrics.';
        }
        return;
      }
      const turns = lastDegradationTurns;
      const modelFromTurn = turns[0] && turns[0].model;
      let commentLines = [];
      commentLines.push('# model,' + (modelFromTurn || ''));
      try {
        const res = await fetch(window.location.origin + '/api/model-info');
        const info = await res.json();
        if (info.quant) commentLines.push('# quant,' + String(info.quant));
        if (info.parameter_size) commentLines.push('# parameter_size,' + String(info.parameter_size));
        if (info.context_length != null) commentLines.push('# context_length,' + info.context_length);
        if (info.size_vram_mb != null) commentLines.push('# size_vram_mb,' + info.size_vram_mb);
      } catch (e) {}
      commentLines.push('# exported,' + new Date().toISOString());
      const headers = ['model', 'turn', 'prompt', 'response', 'prompt_tokens', 'completion_tokens', 'context_tokens', 'kv_cache_mb', 'retrieved_chunks', 'unique_files', 'history_turns', 'latency_ms'];
      const escapeCsv = function(s) {
        const t = String(s == null ? '' : s);
        if (t.indexOf('"') >= 0 || t.indexOf(',') >= 0 || t.indexOf('\n') >= 0) return '"' + t.replace(/"/g, '""') + '"';
        return t;
      };
      const rows = [commentLines.join('\n'), headers.join(',')];
      const modelVal = modelFromTurn || '';
      turns.forEach(function(r) {
        const m = r.metrics || {};
        rows.push([
          escapeCsv(r.model || modelVal),
          r.turn,
          escapeCsv((r.prompt || '').slice(0, 500)),
          escapeCsv((r.response || '').slice(0, 500)),
          m.prompt_tokens ?? '',
          m.completion_tokens ?? '',
          m.context_tokens ?? m.prompt_tokens ?? '',
          m.kv_cache_mb ?? '',
          m.retrieved_chunks ?? '',
          m.unique_files ?? '',
          m.history_turns ?? '',
          m.latency_ms ?? ''
        ].join(','));
      });
      const csv = rows.join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'degradation_metrics_' + new Date().toISOString().slice(0, 10) + '.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function renderDegradationCharts(turns, chartsEl) {
      if (!turns.length) return;
      const chartW = 400; const chartH = 140;
      const hasKvc = turns.some((r) => r.metrics && r.metrics.kv_cache_mb != null);
      chartsEl.innerHTML =
        '<div class="degradation-chart"><h4>Context size (tokens) vs turn</h4>' + drawLineChart('ctx', 'Context tokens', turns, (r) => (r.metrics && (r.metrics.context_tokens ?? r.metrics.prompt_tokens)) || 0, chartW, chartH) + '</div>' +
        '<div class="degradation-chart"><h4>Prompt tokens vs turn</h4>' + drawLineChart('pt', 'Prompt tokens', turns, (r) => (r.metrics && r.metrics.prompt_tokens) || 0, chartW, chartH) + '</div>' +
        (hasKvc ? '<div class="degradation-chart"><h4>KV cache (MB) vs turn</h4>' + drawLineChart('kvc', 'KVC MB', turns, (r) => (r.metrics && r.metrics.kv_cache_mb) || 0, chartW, chartH) + '</div>' : '') +
        '<div class="degradation-chart"><h4>Retrieved chunks vs turn</h4>' + drawLineChart('rc', 'Retrieved chunks', turns, (r) => (r.metrics && r.metrics.retrieved_chunks) || 0, chartW, chartH) + '</div>' +
        '<div class="degradation-chart"><h4>Unique files vs turn</h4>' + drawLineChart('uf', 'Unique files', turns, (r) => (r.metrics && r.metrics.unique_files) || 0, chartW, chartH) + '</div>';
    }

    async function runDegradationTest() {
      const btn = document.getElementById('runDegradationBtn');
      const statusEl = document.getElementById('degradationStatus');
      const resultsEl = document.getElementById('degradationResults');
      const tableWrap = document.getElementById('degradationTableWrap');
      const chartsEl = document.getElementById('degradationCharts');
      btn.disabled = true;
      statusEl.textContent = 'Running… Turn 1/' + NUM_DEGRADATION_TURNS;
      resultsEl.classList.add('visible');
      const modelInfoEl = document.getElementById('degradationModelInfo');
      if (modelInfoEl) modelInfoEl.textContent = '';
      tableWrap.innerHTML = '<table class="degradation-table"><thead><tr><th>Turn</th><th>Prompt tokens</th><th>Completion tokens</th><th>Context (tokens)</th><th>KVC (MB)</th><th>Retrieved chunks</th><th>Unique files</th><th>History turns</th><th>Latency (ms)</th></tr></thead><tbody></tbody></table>';
      chartsEl.innerHTML = '';
      messages.length = 0;
      renderConversation();
      const turns = [];
      const timeoutMs = 25 * 60 * 1000;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      let progressId = null;
      const startTime = Date.now();
      progressId = setInterval(() => {
        if (btn.disabled && statusEl.textContent.indexOf('Done') === -1 && statusEl.textContent.indexOf('Error') === -1) {
          const min = Math.floor((Date.now() - startTime) / 60000);
          const current = turns.length + 1;
          statusEl.textContent = 'Still running… Turn ' + current + '/' + NUM_DEGRADATION_TURNS + ' (' + min + ' min elapsed).';
        }
      }, 30000);
      try {
        let sessionId = null;
        for (let i = 0; i < NUM_DEGRADATION_TURNS; i++) {
          statusEl.textContent = 'Running… Turn ' + (i + 1) + '/' + NUM_DEGRADATION_TURNS;
          const body = { prompt_index: i };
          if (sessionId != null) body.session_id = sessionId;
          const res = await fetch(window.location.origin + '/run-degradation-test-turn', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: controller.signal
          });
          let data = {};
          try { data = await res.json(); } catch (_) {}
          if (!res.ok) {
            statusEl.textContent = 'Error: ' + (data.detail || res.statusText);
            return;
          }
          sessionId = data.session_id;
          turns.push(data);
          appendTurnToUI(data, tableWrap, turns);
          messages.push({ role: 'user', content: data.prompt || '' });
          messages.push({ role: 'assistant', content: data.response || '', turnMetrics: data.metrics });
          renderConversation();
        }
        clearTimeout(timeoutId);
        clearInterval(progressId);
        statusEl.textContent = 'Done. Session: ' + (sessionId || '').slice(0, 8) + '…';
        renderDegradationCharts(turns, chartsEl);
        lastDegradationTurns = turns.slice();
        const last = turns[turns.length - 1];
        const m = (last && last.metrics) || {};
        const avgLat = turns.length ? (turns.reduce(function(s, r) { return s + ((r.metrics && r.metrics.latency_ms) || 0); }, 0) / turns.length) : 0;
        const modelName = (turns[0] && turns[0].model) ? turns[0].model : '';
        let summary = '— Degradation test complete.';
        if (modelName) summary += ' Model: ' + modelName + '.';
        summary += ' Key metrics: ' + turns.length + ' turns, avg latency ' + (avgLat >= 1000 ? (avgLat / 1000).toFixed(1) + 's' : Math.round(avgLat) + 'ms');
        if (m.context_tokens != null) summary += ', final context ' + m.context_tokens + ' tok';
        summary += '. See sidebar for table and charts.';
        messages.push({ role: 'assistant', content: summary, turnMetrics: null });
        renderConversation();
        loadModelInfo();
      } catch (e) {
        clearTimeout(timeoutId);
        if (progressId) clearInterval(progressId);
        if (e.name === 'AbortError') {
          statusEl.textContent = 'Timed out after 25 min. Check that Ollama is running and the model is loaded (e.g. ollama run llama3.1:8b).';
        } else {
          statusEl.textContent = 'Error: ' + (e.message || String(e));
        }
      } finally {
        btn.disabled = false;
      }
    }

    const searchCardEl = document.getElementById('searchCard');
    const searchToggleEl = document.getElementById('searchToggle');
    searchToggleEl.addEventListener('click', () => {
      const collapsed = searchCardEl.classList.toggle('collapsed');
      searchToggleEl.setAttribute('aria-expanded', !collapsed);
    });

    check();
    searchBtnEl.addEventListener('click', searchCorpus);
    searchQueryEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') searchCorpus(); });
    sendEl.addEventListener('click', sendChat);
    promptEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChat(); });
    document.getElementById('runDegradationBtn').addEventListener('click', runDegradationTest);
    document.getElementById('exportMetricsBtn').addEventListener('click', exportMetrics);
  </script>
</body>
</html>
